% File: M.tex
% Created: 2014-11-07
% Author: Tesser Paolo
% Email: p.tesser921@gmail.com
%
%
% Modification History
% Version	Modifier Date	Author			Change
% ====================================================================
% 0.0.1		2014-11-07		Tesser-Paolo	inserita sezione
% ====================================================================
% 0.0.2		2014-11-10		Tesser Paolo	inserita lista con aggiunta di alcune voci
% ====================================================================
% 0.0.3		2015-02-10		Tesser Paolo	inseriti vocaboli: Modelli della qualità, Metriche software
% ====================================================================
%
%

\section{M}

\begin{itemize}


	\item \textbf{Manuale utente}: [DOC] questo documento serve all'utente finale per comprendere come utilizzare il prodotto. Può essere presentato in diversi formati: cartaceo, ipertestuale, documento ipertestuale, ecc... \newline
	Perché sia maggiormente comprensibile deve avere frasi e paragrafi brevi e focalizzati con una buona forma grammaticale. Si consiglia l'uso di liste piuttosto che frasi;


	\item \textbf{MEAN}: si riferisce alle iniziali delle quattro componenti (free e open source) per la costruzione di siti web dinamici. \newline
In particolare è uno stack JavaScript per creare applicazioni web. \newline
I componenti sono:
	\begin{itemize}
		\item Mondo DB : a NoSQL database;
		\item Express.js : un framework per applicazioni web costruito in Node.js;
		\item AngularJS : un framework basato sul design pattern MVC per web app;
		\item Node.js : una piattaforma software per gestire servizi web scalabili.
	\end{itemize}

	\item \textbf{Metrica di progetto (Metrics)}: [MM] sistema di misurazione composto da valori e metodi per valutarli in maniera oggettiva. Le qualità che una metrica deve avere sono:
		\begin{itemize}
			\item \textbf{precisione}: in termini di esattezza e di ripetibilità rispetto ai valori prodotti;
			\item \textbf{aderenza alla realtà}: se la misura corrisponde all'evidenza sperimentale;
			\item \textbf{accuratezza}: corrispondenza con la percezione o la realtà effettiva.
		\end{itemize}

	\item \textbf{Metriche Software}: [QS] sono quei valori che permettono a un prodotto o a un processo di essere quantificabile. Come ad esempio il calcolo dello SLOC (source line of code) per un programma. Esse servono a stimare caratteristiche di un'entità. Vengono identificate da attributi, determinando indicatori per le caratteristiche non misurabili. Secondo il glossario SWE di IEEE la metrica è una misura quantitativa del grado di possesso di uno specifico attributo da parte di un sistema, componente, processo. \newline
	Nella produzione sono strumenti di valutazione e controllo.

	\item \textbf{Metriche Software}: [MM] il software è molto difficile da misurare a causa delle sue caratteristiche molto multiformi. Possiamo classificare alcune metriche basate: sulla grandezza del prodotto, delle sue funzionalità e del suo comportamento. Vediamo ora alcune metriche:
		\begin{itemize}
			\item \textbf{SLOC}: è la metrica più facile e usata, sta ad indicare il numero di linee di codice per file, quantificando anche il rapporto tra commenti e codice vero;
			\item \textbf{Complessità ciclomatica}: è una metrica indipendente dal linguaggio di programmazione e valuta la complessità del flusso di controllo. \'E molto difficile però calcolarla a priori durante la progettazione e consente nel numero  di casi di prova necessari per verificare ogni possibile esito di ogni ramo di decisione della procedura. TODO


			\item \textbf{Function point}: TODO (vedere slide professore)

		\end{itemize}
		\noindent
		Nonostante queste possiamo trovare altre metriche più opportune al un software object oriented come:
		\begin{itemize}
			\item metriche per le classi
			\item metriche per i metodi
			\item metriche per i sistemi
		\end{itemize}


	\item \textbf{Metriche per le classi}: [MM] TODO (vedere slide professore)

	\item \textbf{Metriche per i metodi}: [MM] TODO (vedere slide professore)


	\item \textbf{Milestone}: [PM] TODO;

	\item \textbf{Misurare}: [MM] questa attività deve essere svolta per conoscere e per giudicare. La misura serve per rendere oggettivi i risultati degli esperimenti effettuati e per avere dati affidabili su cui basare modelli matematici. Proprio la sua oggettività implica potere essere ripetibili e confrontabili. La misura comunque può incontrare qualche limite come le approssimazioni di realtà fisiche.
		\begin{itemize}
			\item \textbf{Misurazione}: processo che assegna numeri o simboli ad attributi di entità del mondo reale per descriverle secondo \textbf{regole} definite;
			\item \textbf{Misura}: è il risultato della misurazione. \'E anche un'assegnazione empirica e oggettiva di un valore a un'entità per caratterizzarne un attributo specifico;
			\item \textbf{Metrica} = insieme di regole: servono per fissare le entità da misurare, gli attributi rilevanti, l'unità di misura, la procedura per assegnare e interpretare i valori.
		\end{itemize}
		\noindent
		Bisogna anche tenere conto di caratteristiche difficilmente misurabili. Bisogna allora domandarsi se la misura desiderata può essere ottenuta indirettamente a partire da altre misure ottenute tramite stime o predizioni \textbf{(indicatori)}. \newline
		Le entità che vanno misurate sono:
			\begin{itemize}
				\item processi: insieme di procedure astratte
				\item progetti: attività concrete legate a tempo e risorse
				\item prodotti: beni e servizi in uscita da progetti
				\item risorse: elementi impiegati e consumati dal progetto
			\end{itemize}
			\noindent
		Le categorie di attributi possono essere: \textbf{interni} se sono misurabili rispetto alle entità, \textbf{esterni} se sono misurabili rispetto all'ambiente. L'obiettivo della misurazione è quello di valutare lo stato di: progetti (stime, preventivi e consuntivi), prodotti (qualità), processi (qualità, miglioramenti), risorse (consumo).
		Dopo avere valutato le misurazioni bisogna decidere quali azioni correttive intraprendere. \newline
		Alcuni frasi celebri:
			\begin{itemize}
				\item Misura ciò che è misurabile e rendi misurabile ciò che non lo è. (Galileo Galilei)
				\item If you cannot mesure it, you cannot improve it. (Lord William Thomson Kelvin)
				\item You can't control what you can't mesure. (Tom de Marco)
			\end{itemize}
			\noindent
			Capire cosa misurare non è semplice, bisogna partire cercando tra alcune fonti come ``Practical Software Measurement''. Il CMMI suggerisce alcune aree su cui determinare questi valori:
				\begin{itemize}
					\item gestione dei requisiti
					\item progettazione e implementazione
					\item verifica e validazione
					\item controllo di qualità
					\item gestione delle correzioni
					\item gestione di progetto
					\item analisi dei rischi e delle decisioni
				\end{itemize}
				\noindent
				Alcuni esempi proposti dal CMMI: quanto le pratiche in uso aderiscono a quelli di riferimento o quanto i prodotti del progetto soddisfano i requisiti. Quali rischi gravano attualmente e quanto. Quanto sono affidabili i preventivi rispetto ai consuntivi;

	\item \textbf{Modelli agili}: [PM] è uno dei modelli di ciclo di vita del SW. \newline
Nell'idea pura della metodologia agile viene perso il legame con l'ingegneria del software.
Quello che viene proposto infatti è che le persone sono più importanti dei processi e degli strumenti imposti. Di seguito sono riportati i quattro principi fondanti:
		\begin{enumerate}
			\item gli individui e le interazioni tra di essi sono più importanti dei processi e degli strumenti;
			\item un software funzionante piuttosto che una documentazione comprensiva;
			\item collaborazione con il cliente piuttosto che una negoziazione contrattuale;
			\item adattarsi ai cambiamenti piuttosto che seguire un piano preciso e rigido.
		\end{enumerate}
Questo modello ha come obiettivi quelli di riuscire a dimostrare costantemente al cliente quanto è stato fatto. Ciò da maggiore soddisfazione agli sviluppatori che vedono in breve tempo l'avanzamento del risultato finale. \newline
Alcune tecniche agili sono: Scrum (caos organizzato) e Kanban (just-in-time).

	\item \textbf{Modello a componenti}: [PM] è uno dei modelli di ciclo di vita del SW. Nasce dall'osservazione che molto di quello che ci serve esiste già e molto di quello che faremo ci servirà ancora. \newline
Generalmente costa meno come approccio e, se è stato fatto bene il componente che andremo ad integrare, ci sarà una buona probabilità che sia già testato.

	\item \textbf{Modelli della qualità}: [QS] sono degli strumenti utili alla gestione per la qualità mediante valutazione della qualità dei prodotti. Essi si riferiscono a diverse visioni riguardo:
		\begin{itemize}
			\item l'utente: rispetto all'uso del prodotto;
			\item la produzione: rispetto a qualifica, manutenzione, portabilità e riuso del prodotto;
			\item la direzione: rispetto al rapporto costi/benefici.
		\end{itemize}
		\noindent
		\'E buona pratica utilizzare un solo modello per committenti e fornitori, in modo da uniformare la percezione e la valutazione della qualità. Alcuni tra i più diffusi modelli sono quelli di Boehm o quello ISO/IEC 9126:2001. In quest'ultimo sono presenti 7 caratteristiche principali suddivise ulteriormente in 31 sotto caratteristiche che fanno raggiungere la qualità a un prodotto software;

	\item \textbf{Modello evolutivo}: [PM] è uno dei modelli di ciclo di vita del SW. Esso aiuta a rispondere a bisogni non inizialmente preventivabili. Non si sa dove si vuole andare, ma si procede migliorando. \newline
Può richiedere il rilascio e il mantenimento di più versioni esterne in parallelo che consentono una presenza molto vasta sul mercato ,ma ciò può essere estremamente costoso se il prodotto è di tipo commerciale. Alcuni esempi di ciò riguardano Google Chrome e Firefox.

	\item \textbf{Modello incrementale}: [PM] è uno dei modelli di ciclo di vita del SW. Prevede rilasci multipli e successivi nei quali avviene un incremento di funzionalità. \newline
Alcune fasi però, come l'analisi e la progettazione, non vengono ripetute. Solo la realizzazione assume carattere incrementale iniziando dai requisiti essenziali per poi terminare con quelli desiderabile. In tal modo, già dopo non troppo tempo, si possono mostrare i risultati al committente e ricevere dei feedback. \newline
Così è più facile e meno costoso effettuare dei miglioramenti o dei raffinamenti se necessario;

	\item \textbf{Modello sequenziale (a cascata)}: [PM] è uno dei modelli di ciclo di vita del SW più consolidati e autoritari. Prevede una successione di fasi rigidamente sequenziali, non ammettendo ritorni a stati precedenti. Se si verificano eventi eccezionali, essi faranno ripartire dall'inizio. \newline
Per passare da uno stato ad un altro vengono introdotte delle PRE e delle POST condizioni molto forti definite all'origine. Le fasi previste sono: Analisi, Progettazione, Realizzazione, Manutenzione. Esse sono distinte e non si sovrappongono. \newline
Questo modello però pecca di eccessiva rigidità e spesso il committente non sa da subito quali sono le sue esigenze in maniera precisa.\newline
Ci sono quindi delle correzioni che si possono apportare per renderlo più flessibile. Si può fare della prototipazione solo per capire meglio i requisiti o attuare dei ritorni, in modo che ogni ciclo di ritorno raggruppo delle sotto sequenze di fasi;

	\item \textbf{Modello a spirale}: [PM] è uno dei modelli di ciclo di vita del SW. Viene impiegato in progetti fortemente innovativi perché si ha un miglior controllo dei rischi (risk driven). \newline
Si attua mediante cicli interni rapidi e ripetuti che consistono in analisi e sviluppo di prototipi, mentre per i cicli esterni si può aderire a un qualsiasi degli altri modelli. \newline
Richiede quindi forte interazione tra il committente e il fornitore. Le fasi presenti sono: definizione degli obiettivi, l'analisi dei rischi, sviluppo e validazione, pianificazione per poi riprendere dall'inizio;


	\item \textbf{Modulo}: aggregato più piccolo che possa dare in pasto a un programmatore. Ognuno ha dimensione, coesione, complessità e accoppiamento appropriati per la codifica in parallelo. La natura di un modulo è determinata dal linguaggio di programmazione in uso;


\end{itemize}